//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  HTTPTask.swift
//
//  Created by Dalton Cherry on 6/3/14.
//  Copyright (c) 2014 Vluxe. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////////////////////////////

import Foundation
import LinUtil
import CoreData


fileprivate func < <T : Comparable>(lhs: T?, rhs: T?) -> Bool {
switch (lhs, rhs) {
case let (l?, r?):
return l < r
case (nil, _?):
return true
default:
return false
}
}

fileprivate func > <T : Comparable>(lhs: T?, rhs: T?) -> Bool {
switch (lhs, rhs) {
case let (l?, r?):
return l > r
default:
return rhs < lhs
}
}


/// Object representation of a HTTP Response.

internal class HttpTaskParams{
public var url: String;

public init(url:String){
self.url = url;
}
public var identifier:String?;
public var method: HttpMethod = HttpMethod.GET;
public var parameters: Dictionary<String,AnyObject>?;
public var headers:Dictionary<String,String>?;
public var success:((HttpClientResponse) -> Void)?;
public var failure:((NSError, HttpResponse?) -> Void)?;
public var progress:((_ down: Int64, _ expected: Int64, _ bytes: Int64)->Void)?;
fileprivate var isMulti:Bool?;
public var timeout:TimeInterval?;
}
/// Holds the blocks of the background task.
//internal class BackgroundBlocks {
//    // these 2 only get used for background download/upload since they have to be delegate methods
//    var success:((_ response:HttpClientResponse) -> Void)?
//    var failure:((_ error:NSError, _ response:HttpClientResponse?) -> Void)?
////    var progress:((Double) -> Void)?
//    var progress:((_ down: Int64, _ expected: Int64, _ bytes: Int64)->Void)?;
//
//
//    /**
//        Initializes a new Background Block
//
//        - parameter success: The block that is run on a sucessful HTTP Request.
//        - parameter failure: The block that is run on a failed HTTP Request.
//        - parameter progress: The block that is run on the progress of a HTTP Upload or Download.
//    */
//    init(_ success: ((HttpClientResponse) -> Void)?, _ failure: ((NSError, HttpClientResponse?) -> Void)?,_ progress: ((_ down: Int64, _ expected: Int64, _ bytes: Int64)->Void)?) {
//        self.failure = failure
//        self.success = success
//        self.progress = progress
//    }
//}

/// Subclass of NSOperation for handling and scheduling HTTPTask on a NSOperationQueue.
open class HttpOperation : Operation {
fileprivate var task: URLSessionDataTask!
fileprivate var stopped = false
fileprivate var running = false

/// Controls if the task is finished or not.
open var done = false

//MARK: Subclassed NSOperation Methods

/// Returns if the task is asynchronous or not. This should always be false.
override open var isAsynchronous: Bool {
return false
}

/// Returns if the task has been cancelled or not.
override open var isCancelled: Bool {
return stopped
}

/// Returns if the task is current running.
override open var isExecuting: Bool {
return running
}

/// Returns if the task is finished.
override open var isFinished: Bool {
return done
}

/// Returns if the task is ready to be run or not.
override open var isReady: Bool {
return !running
}

/// Starts the task.
override open func start() {
super.start()
stopped = false
running = true
done = false
task.resume()
}

/// Cancels the running task.
override open func cancel() {
super.cancel()
running = false
stopped = true
done = true
task.cancel()
}

/// Sets the task to finished.
open func finish() {
self.willChangeValue(forKey: "isExecuting")
self.willChangeValue(forKey: "isFinished")

running = false
done = true

self.didChangeValue(forKey: "isExecuting")
self.didChangeValue(forKey: "isFinished")
}
}

/// Configures NSURLSession Request for HTTPOperation. Also provides convenience methods for easily running HTTP Request.
internal class HttpTask : NSObject, URLSessionDelegate, URLSessionTaskDelegate {
private struct YSInstance{
//        static var backgroundTaskMap = Dictionary<String,BackgroundBlocks>();
static var backgroundTaskMap = Dictionary<String,HttpTaskParams>();
//        static var forBackgroundURLSession:Bool = false;
static var completionHandlerDictionary = Dictionary<String,() -> Swift.Void>();
static var coreDataContext:NSManagedObjectContext! = nil;
}

private static let __init:() = {
// 从应用程序包中加载模型文件
//        NSManagedObjectModel *model = [NSManagedObjectModel mergedModelFromBundles:nil];

// 传入模型对象，初始化NSPersistentStoreCoordinator
//        NSPersistentStoreCoordinator *psc = [[[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model] autorelease];
let model = NSManagedObjectModel.mergedModel(from: nil);
let psc = NSPersistentStoreCoordinator.init(managedObjectModel: model!);
// 构建SQLite数据库文件的路径
//        NSString *docs = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
let docs = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.cachesDirectory, FileManager.SearchPathDomainMask.allDomainsMask, true).last as NSString?;
//        NSURL *url = [NSURL fileURLWithPath:[docs stringByAppendingPathComponent:@"person.data"]];
let url = NSURL.fileURL(withPath: docs?.appendingPathComponent("coredata.data") ?? "");
// 添加持久化存储库，这里使用SQLite作为存储库
//        NSError *error = nil;
//        NSPersistentStore *store = [psc addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:url options:nil error:&error];
//        let store = try? psc.addPersistentStore(ofType: NSSQLiteStoreType, configurationName: nil, at: url, options: nil);
////        if (store == nil) { // 直接抛异常
////            [NSException raise:@"添加数据库错误" format:@"%@", [error localizedDescription]];
////        }
////        // 初始化上下文，设置persistentStoreCoordinator属性
////        NSManagedObjectContext *context = [[NSManagedObjectContext alloc] init];
////        context.persistentStoreCoordinator = psc;
//        YSInstance.coreDataContext = NSManagedObjectContext();
//        YSInstance.coreDataContext.persistentStoreCoordinator = psc;
}()

public func addHandleEventsForBackgroundURLSession(identifier: String, completionHandler: @escaping () -> Swift.Void){
YSInstance.completionHandlerDictionary[identifier] = completionHandler;
//        let config = URLSessionConfiguration.background(withIdentifier: identifier);
//        _ = Foundation.URLSession(configuration: config, delegate: self, delegateQueue: nil);

let data = BackgroundDown();

_ = HttpTask.__init;
//        NSEntityDescription.i
}
//var sess: NSURLSession?

open var baseURL: String?
open var httpDns:HttpDNS?;
private var requestSerializer = HttpRequestSerializer()
open var responseSerializer: HttpResponseSerializer?
//This gets called on auth challenges. If nil, default handling is use.
//Returning nil from this method will cause the request to be rejected and cancelled
open var auth:((URLAuthenticationChallenge) -> URLCredential?)?

fileprivate var impl:HttpCommunicateImpl
//MARK: Public Methods

/// A newly minted HTTPTask for your enjoyment.

//private var config:NSURLSessionConfiguration;// = NSURLSessionConfiguration.defaultSessionConfiguration()
//private var cookies:NSHTTPCookieStorage;
//private var session:Foundation.URLSession!;//(configuration: config, delegate: self, delegateQueue: nil)
fileprivate var session:URLSession!;
public init(impl:HttpCommunicateImpl) {
//self.config = NSURLSessionConfiguration.defaultSessionConfiguration();
//self.config.HTTPCookieStorage = NSHTTPCookieStorage();
//self.cookies = NSHTTPCookieStorage()

// makes no difference whether it's set or left at default
//self.config.HTTPCookieStorage = self.cookies;
//self.config.HTTPCookieAcceptPolicy = NSHTTPCookieAcceptPolicy.Always
self.impl = impl;
super.init()

_ = HttpTask.__init;

let config:URLSessionConfiguration = URLSessionConfiguration.default;
self.session = Foundation.URLSession(configuration: config, delegate: self, delegateQueue: nil)

//        let config:URLSessionConfiguration = URLSessionConfiguration.default;
//        var c = config.HTTPCookieStorage;
//        config.HTTPCookieStorage = NSHTTPCookieStorage()
//        println("cookies:\(c)");
//        for var n=0;n<c?.cookies?.count;n++ {
//            println("item:\(c?.cookies?[n])");
//            var hc = c?.cookies?[n] as NSHTTPCookie;
//            config.HTTPCookieStorage?.setCookie(hc);
//        }

//        println("cookies:\(config.HTTPCookieStorage)");
//        var c2 = c?.cookies;
//        config.HTTPCookieStorage.cookies = c2;
//config.
}

//    public func GET(_ url: String, parameters: Dictionary<String,AnyObject>?, headers:Dictionary<String,String>, success:((HttpResponse) -> Void)!, failure:((NSError, HttpResponse?) -> Void)!) {
//        let opt = self.create(url, method:.GET, parameters: parameters,headers:headers,success: success,failure: failure)
//        if opt != nil {
//            opt!.start()
//        }
//    }
//
//    public func POST(_ url: String, parameters: Dictionary<String,AnyObject>?, headers:Dictionary<String,String>, success:((HttpResponse) -> Void)!, failure:((NSError, HttpResponse?) -> Void)!) {
//        let opt = self.create(url, method:.POST, parameters: parameters,headers:headers,success: success,failure: failure)
//        if opt != nil {
//            opt!.start()
//        }
//    }
//
//    public func PUT(_ url: String, parameters: Dictionary<String,AnyObject>?, headers:Dictionary<String,String>, success:((HttpResponse) -> Void)!, failure:((NSError, HttpResponse?) -> Void)!) {
//        let opt = self.create(url, method:.PUT, parameters: parameters,headers:headers,success: success,failure: failure)
//        if opt != nil {
//            opt!.start()
//        }
//    }
//
//    public func DELETE(_ url: String, parameters: Dictionary<String,AnyObject>?, headers:Dictionary<String,String>, success:((HttpResponse) -> Void)!, failure:((NSError, HttpResponse?) -> Void)!)  {
//        let opt = self.create(url, method:.DELETE, parameters: parameters,headers:headers,success: success,failure: failure)
//        if opt != nil {
//            opt!.start()
//        }
//    }
//
//    public func HEAD(_ url: String, parameters: Dictionary<String,AnyObject>?, headers:Dictionary<String,String>, success:((HttpResponse) -> Void)!, failure:((NSError, HttpResponse?) -> Void)!) {
//        let opt = self.create(url, method:.HEAD, parameters: parameters,headers: headers,success: success,failure: failure)
//        if opt != nil {
//            opt!.start()
//        }
//    }

/**
Creates a HTTPOperation that can be scheduled on a NSOperationQueue. Called by convenience HTTP verb methods below.

- parameter url: The url you would like to make a request to.
- parameter method: The HTTP method/verb for the request.
- parameter parameters: The parameters are HTTP parameters you would like to send.
- parameter success: The block that is run on a sucessful HTTP Request.
- parameter failure: The block that is run on a failed HTTP Request.

- returns: A freshly constructed HTTPOperation to add to your NSOperationQueue.
*/
//    public func create(_ url: String, method: HttpMethod, parameters: Dictionary<String,AnyObject>!,headers:Dictionary<String,String>, success:((HttpResponse) -> Void)!, failure:((NSError, HttpResponse?) -> Void)!) ->  HttpOperation? {
public func create(params:HttpTaskParams)->HttpOperation?{

////        if YSInstance.completionHandlerDictionary.count > 0 {
//        let config = URLSessionConfiguration.background(withIdentifier:"identifier1");
//        _ = Foundation.URLSession(configuration: config, delegate: self, delegateQueue: nil);
//        let config2 = URLSessionConfiguration.background(withIdentifier:"identifier2");
//        _ = Foundation.URLSession(configuration: config2, delegate: self, delegateQueue: nil);
////        }




//        let serialReq = createRequest(url, method: method, parameters: parameters,headers:headers)
let serialReq = createRequest(params: params);
if let error = serialReq.error {
//            if params.failure != nil {
params.failure?(error, nil)
//            }
return nil
}
let opt = HttpOperation()

let task = session.dataTask(with: serialReq.request,
completionHandler: {(data: Data?, response: URLResponse?, error: Error?) -> Void in
opt.finish()
self.processResponse(params.success,failure:params.failure,data:data,response:response,error:error as NSError!);

});
opt.task = task
return opt
}

private func processResponse(_ success:((HttpClientResponse) -> Void)!, failure:((NSError, HttpClientResponse?) -> Void)!,data: Data!, response: URLResponse!, error: NSError!){
if error != nil {
if failure != nil {
failure(error, nil)
}
return
}
if let data = data {
var responseObject: AnyObject = data as AnyObject
if self.responseSerializer != nil {
let resObj = self.responseSerializer!.responseObjectFromResponse(response, data: data)
if resObj.error != nil {
if failure != nil {
failure(resObj.error!, nil)
}
return
}
if resObj.object != nil {
responseObject = resObj.object!
}
}
let extraResponse = HttpClientResponse()
if let hresponse = response as? HTTPURLResponse {
extraResponse.headers = hresponse.allHeaderFields as? Dictionary<String,String>
extraResponse.mimeType = hresponse.mimeType
extraResponse.suggestedFilename = hresponse.suggestedFilename
extraResponse.statusCode = hresponse.statusCode
extraResponse.URL = hresponse.url
}
extraResponse.responseObject = responseObject
if extraResponse.statusCode > 299 {
if failure != nil {
failure(self.createError(extraResponse.statusCode), extraResponse)
//                    let error = self.createError(extraResponse.statusCode)
//                    failure(error,extraResponse);
}
} else if success != nil {
success(extraResponse)
}
} else if failure != nil {
failure(error, nil)
}
}

/**
Creates and starts a HTTPOperation to download a file in the background.

- parameter url: The url you would like to make a request to.
- parameter parameters: The parameters are HTTP parameters you would like to send.
- parameter progress: The progress returned in the progress block is between 0 and 1.
- parameter success: The block that is run on a sucessful HTTP Request. The HTTPResponse responseObject object will be a fileURL. You MUST copy the fileURL return in HTTPResponse.responseObject to a new location before using it (e.g. your documents directory).
- parameter failure: The block that is run on a failed HTTP Request.
*/
//    public func download(_ url: String,identifier:String?,method:HttpMethod, parameters: Dictionary<String,AnyObject>?,headers:Dictionary<String,String>, success:((HttpClientResponse) -> Void)!, failure:((NSError, HttpClientResponse?) -> Void)!, progress:((_ down: Int64, _ expected: Int64, _ bytes: Int64)->Void)!) -> URLSessionDownloadTask? {
public func download(params:HttpTaskParams)->URLSessionDownloadTask?{
//        let serialReq = createRequest(url,method: method, parameters: parameters,headers:headers)
let serialReq = createRequest(params: params);
if serialReq.error != nil {
params.failure?(serialReq.error!, nil)
return nil
}

var ident:String!;

if let identifier = params.identifier {
ident = identifier;
}else{
ident = createBackgroundIdent();
}

let config = URLSessionConfiguration.background(withIdentifier: ident);
let session = Foundation.URLSession(configuration: config, delegate: self, delegateQueue: nil);

let task = session.downloadTask(with: serialReq.request)

YSInstance.backgroundTaskMap["\(ident)\(task.hash)"] = params;// BackgroundBlocks(params.success,params.failure,params.progress)
//        if YSInstance.forBackgroundURLSession {
//            Queue.mainQueue {
//                UIAlertView(title: "", message: "2:\(url)", delegate: nil, cancelButtonTitle: "ok").show();
//            }
//            return nil;
//        }
task.resume()
return task
}

//TODO: not implemented yet.
/// not implemented yet.
//    public func uploadFile(_ url: String, identifier:String?, parameters: Dictionary<String,AnyObject>?, headers:Dictionary<String,String>, progress:((_ send:Int64,_ total:Int64,_ bytes:Int64) -> Void)!, success:((HttpResponse) -> Void)!, failure:((NSError,HttpClientResponse?) -> Void)!) -> Void {
public func uploadFile(params:HttpTaskParams){


//        let serialReq = createRequest(url,method: .GET, parameters: parameters,isMulti:true,headers:headers)
let serialReq = createRequest(params: params);
if let error = serialReq.error {
params.failure?(error,nil)
return
}
//        self.uploadProgress = progress;
//        self.uploadSuccess = success;
//        self.uploadFailure = failure;

var ident:String!;

if let identifier = params.identifier {
ident = identifier;
}else{
ident = createBackgroundIdent();
}

let config = URLSessionConfiguration.background(withIdentifier: ident);
let session = Foundation.URLSession(configuration: config, delegate: self, delegateQueue: nil);

//        let task = session.downloadTask(with: serialReq.request)
let task = session.uploadTask(withStreamedRequest: serialReq.request);
YSInstance.backgroundTaskMap["\(ident)\(task.hash)"] = params;//BackgroundBlocks(success,failure,progress)
//        var task = session.uploadTaskWithRequest(serialReq.request, fromData: nil);
//        let task = session.uploadTask(with: serialReq.request, from:nil, completionHandler: {(data:Data?,response: URLResponse?, error:Error?) in
//            self.processResponse(success,failure:failure,data:data,response:response,error:error as NSError!);
//        });
task.resume();

}

//    private var uploadProgress:((Int64,Int64) -> Void)!;
//    private var uploadSuccess:((HttpResponse) -> Void)!;
//    private var uploadFailure:((NSError,HttpResponse) -> Void)!;

//MARK: Private Helper Methods

/**
Creates and starts a HTTPOperation to download a file in the background.

- parameter url: The url you would like to make a request to.
- parameter method: The HTTP method/verb for the request.
- parameter parameters: The parameters are HTTP parameters you would like to send.

- returns: A NSURLRequest from configured requestSerializer.
*/
//    fileprivate func createRequest(_ url: String, method: HttpMethod, parameters: Dictionary<String,AnyObject>!,isMulti:Bool? = nil,headers:Dictionary<String,String>?,timeout:TimeInterval) -> (request: URLRequest, error: NSError?) {
private func createRequest(params:HttpTaskParams)->(request:URLRequest,error:NSError?){
var urlVal = params.url
//probably should change the 'http' to something more generic
if !params.url.hasPrefix("http") && self.baseURL != nil {
let split = params.url.hasPrefix("/") ? "" : "/"
urlVal = "\(self.baseURL!)\(split)\(params.url)"
}

var nsurl = URL(string: urlVal);

var hostName:String?;
var ip:String?;

if let httpDns = self.httpDns {
hostName = nsurl!.host;
//            ip = [httpDNS getIpByHost:hostName];
ip = httpDns.getIpByHost(hostName!);
if ip != nil {

let hostFirstRange = urlVal.range(of: hostName!);
if let hostFirstRange = hostFirstRange {
let newUrl = urlVal.replacingCharacters(in: hostFirstRange, with: ip!);
nsurl = URL(string: newUrl);
}else{
ip = nil;
}
}


}

let result = self.requestSerializer.createRequest(URL(string: urlVal)!,
method: params.method, parameters: params.parameters,isMulti : params.isMulti);

var request = result.request;
if let headers = params.headers {
for (key,value) in headers {
request.addValue(value,forHTTPHeaderField:key);
}
}

//        result.request.setValue("",forHTTPHeaderField:HTTP_COMM_PROTOCOL);
//        if isDebug {
//            result.request.setValue("",forHTTPHeaderField:HTTP_COMM_PROTOCOL_DEBUG);
//        }
if ip != nil {
request.addValue(hostName ?? "", forHTTPHeaderField: "Host");
}
if let timeout = params.timeout {
request.timeoutInterval = timeout;
}
return result;
}

/**
Creates a random string to use for the identifier of the background download/upload requests.

- returns: Identifier String.
*/
fileprivate func createBackgroundIdent() -> String {
let letters = "1234567890!@#$%^&*()-_=+`~qwertyuioplkjhgfdsazxcvbnmQWERTYUIOPLKJHGFDSAZXCVBNM[]:,<';./>?|"
var str = ""
for _ in 0 ..< 64 {
let start = Int(arc4random() % 90);
str.append(letters[letters.characters.index(letters.startIndex, offsetBy: start)])
}
return "background iden:\(str)";
}

/**
Creates a random string to use for the identifier of the background download/upload requests.

- parameter code: Code for error.

- returns: An NSError.
*/
fileprivate func createError(_ code: Int) -> NSError {
var text = "An error occured"
if code == 404 {
text = "page not found"
} else if code == 401 {
text = "accessed denied"
}
return NSError(domain: "HTTPTask", code: code, userInfo: [NSLocalizedDescriptionKey: text])
}


/**
Creates a random string to use for the identifier of the background download/upload requests.

- parameter identifier: The identifier string.

- returns: An NSError.
*/
fileprivate func cleanupBackground(_ identifier: String) {
YSInstance.backgroundTaskMap.removeValue(forKey: identifier)
}

//MARK: NSURLSession Delegate Methods

/// Method for authentication challenge.
public func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: (Foundation.URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
if let a = auth {
let cred = a(challenge)
if let c = cred {
completionHandler(.useCredential, c)
}
completionHandler(.rejectProtectionSpace, nil)
return
}
completionHandler(.performDefaultHandling, nil)
}

/// Called when the background task failed.
public func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
//        Queue.mainQueue {
//            UIAlertView(title: "", message: "didCompleteWithError:\(session.configuration.identifier)", delegate: nil, cancelButtonTitle: "ok").show();
//        }
if error != nil {
//            print("error:\(error)");
//            Queue.mainQueue {
//                UIAlertView(title: "", message: "error:\(error)", delegate: nil, cancelButtonTitle: "ok").show();
//            }
//            println("identifier:\(session.configuration)");
//            println("identifier:\(session.configuration.identifier)");
//            let blocks = self.backgroundTaskMap[session.configuration.identifier]
//            if blocks?.failure != nil { //Swift bug. Can't use && with block (radar: 17469794)
//                blocks?.failure!(error, nil)
//                cleanupBackground(session.configuration.identifier)
//            }
}
session.finishTasksAndInvalidate();
}

/// The background download finished and reports the url the data was saved to.
func URLSession(_ session: Foundation.URLSession!, downloadTask: URLSessionDownloadTask!, didFinishDownloadingToURL location: URL!) {

//        if YSInstance.forBackgroundURLSession {
//            Queue.mainQueue {
//                UIAlertView(title: "", message: "url:\(location)", delegate: nil, cancelButtonTitle: "ok").show();
//            }
//        }
let blocks = YSInstance.backgroundTaskMap["\(session.configuration.identifier)\(downloadTask.hash)"]
if blocks?.success != nil {
let resp = HttpClientResponse()
if let hresponse = downloadTask.response as? HTTPURLResponse {
resp.headers = hresponse.allHeaderFields as? Dictionary<String,String>
resp.mimeType = hresponse.mimeType
resp.suggestedFilename = hresponse.suggestedFilename
resp.statusCode = hresponse.statusCode
resp.URL = hresponse.url
}
resp.responseObject = location as AnyObject?
if resp.statusCode > 299 {
//                if blocks?.failure != nil {
blocks?.failure?(self.createError(resp.statusCode), resp)
//                }
return
}
blocks?.success?(resp)
//            cleanupBackground(session.configuration.identifier!)
cleanupBackground("\(session.configuration.identifier)\(downloadTask.hash)")
}
}

/// Will report progress of background download
// didWriteData：本次写入的数据大小
// totalBytesWritten：共下载了多少数据
// totalBytesExpectedToWrite：估计大小，也就是总数据大小
func URLSession(_ session: Foundation.URLSession!, downloadTask: URLSessionDownloadTask!, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
//        let increment = 100.0/Double(totalBytesExpectedToWrite)
//        var current = (increment*Double(totalBytesWritten))*0.01
//
////        ((100.0/Double(totalBytesExpectedToWrite))*Double(totalBytesWritten))*0.01
////
////        totalBytesWritten/totalBytesExpectedToWrite
//
//        if current > 1 {
//            current = 1;
//        }
//        let blocks = self.backgroundTaskMap[session.configuration.identifier!]
//        print("totalBytesWritten:\(totalBytesWritten),totalBytesExpectedToWrite:\(totalBytesExpectedToWrite), bytesWritten:\(bytesWritten)")
let blocks = YSInstance.backgroundTaskMap["\(session.configuration.identifier)\(downloadTask.hash)"]
//        if blocks?.progress != nil {
blocks?.progress?(totalBytesWritten,totalBytesExpectedToWrite, bytesWritten);
//        }
}

//private var forBackgroundURLSession:Bool = false;
/// The background download finished, don't have to really do anything.
public func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {

if let identifier = session.configuration.identifier {
YSInstance.completionHandlerDictionary[identifier]?();
}

}

//TODO: not implemented yet.
/// not implemented yet. The background upload finished and reports the response data (if any).
func URLSession(_ session: Foundation.URLSession!, dataTask: URLSessionDataTask!, didReceiveData data: Data!) {
//add upload finished logic
//        var str = NSString(data: data, encoding: String.Encoding.utf8.rawValue);
//        dataTask.response
//        if let success = self.uploadSuccess {
//            var response = HttpResponse();
//            response.responseObject = data;
//            success(response);
//        }
let blocks = YSInstance.backgroundTaskMap["\(session.configuration.identifier)\(dataTask.hash)"]
if blocks?.success != nil {
let resp = HttpClientResponse()
if let hresponse = dataTask.response as? HTTPURLResponse {
resp.headers = hresponse.allHeaderFields as? Dictionary<String,String>
resp.mimeType = hresponse.mimeType
resp.suggestedFilename = hresponse.suggestedFilename
resp.statusCode = hresponse.statusCode
resp.URL = hresponse.url
}
resp.responseObject = data as NSData?;
if resp.statusCode > 299 {
//                if blocks?.failure != nil {
blocks?.failure?(self.createError(resp.statusCode), resp)
//                }
return
}
blocks?.success?(resp)
//            cleanupBackground(session.configuration.identifier!)
cleanupBackground("\(session.configuration.identifier)\(dataTask.hash)")
}
}

//TODO: not implemented yet.
/// not implemented yet.
public func urlSession(_ session: URLSession, task: URLSessionTask, didSendBodyData bytesSent: Int64, totalBytesSent: Int64, totalBytesExpectedToSend: Int64) {
//add progress block logic
//        if let progress = self.uploadProgress {
//            progress(totalBytesSent,totalBytesExpectedToSend);
//        }
let blocks = YSInstance.backgroundTaskMap["\(session.configuration.identifier)\(task.hash)"]
//        if blocks?.progress != nil {
blocks?.progress?(totalBytesSent,totalBytesExpectedToSend, bytesSent);
}

//TODO: not implemented yet.
/// not implemented yet.
func URLSession(_ session: Foundation.URLSession!, downloadTask: URLSessionDownloadTask!, didResumeAtOffset fileOffset: Int64, expectedTotalBytes: Int64) {
print("ok.");
}

deinit{
print("http task deinit.");
}
}
